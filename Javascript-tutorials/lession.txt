1.
=> npm init -y
npm install express
for nodemon
 npm i nodemon 
 Server connection using nodeJs with expressJS?
 Solution: - 
const express = require('express');
const PORT = 8000;
const app =express();
app.listen(PORT, ()=>{
    console.log(`Server is running at ${PORT}`);
});

2. Difference between promise all and promise Any
Promise all: - Wait the all sucessive result and execute it parallely
If any promise fails, the entire Promise.all() fails with that error.

A) Promise.all() ‚Äî Run Promises in Parallel

 for example:-
const p1 = Promise.resolve("first);
const p2 = Promise.resolve("second);
const p3 = Promise.resolve("third);

Promise.all([p1,p2,p3])
.then(data=>{
    console.log(data)
})  //output: -['first', 'second', 'third']

B) Promise.any() -
Returns the first fulfilled promise, ignores rejections.

const p1 = Promise.reject('fails')
const p2 = Promise.reject('fails')
const p3 =Promise.resolve('success')
Promise.any([p1,p2,p3])
.then(result=> {
    console.log(result)
}) // output: - success

C) Promise.race() - 
Return first settled promise either resolve or reject

const p1 = new Promise((resolve) => setTimeout(() => resolve("first"), 1500));
const p2 = new Promise((resolve) => setTimeout(() => resolve("seconds"), 500));
Promise.race([p1, p2]).then((result) => {
  console.log(result);
});
//output- seconds
D) Promise.allSettled() -
 return all fail and success response

 const p1 =new Promise.resolve('success');
 const p2 = new Promise.reject('fail');
 const p3 =new Promise.resolve('done');

Promise.allSettled([p1, p2, p3]).then((result) => {
  console.log(result);
});

//output { status: 'fulfilled', value: 'Success' },
  { status: 'rejected', reason: 'Failed' },
  { status: 'fulfilled', value: 'Done' }


  | Promise Method         | Description                                      |
| ---------------------- | ------------------------------------------------ |
| `new Promise()`        | Create a new Promise                             |
| `.then()`              | Handle success                                   |
| `.catch()`             | Handle error                                     |
| `.finally()`           | Always runs after then/catch                     |
| `Promise.all()`        | Wait for all promises, fails fast                |
| `Promise.allSettled()` | Wait for all, returns both fulfilled/rejected    |
| `Promise.race()`       | Returns first settled (win or fail)              |
| `Promise.any()`        | Returns first **successful**, ignores rejections |



Q.3 Difference between null and undefined
Example
let a = null;
typeof null is object
let b; // b is undefined  // typeof undefined is undefined

Q.4) Explain Promise
Solution:- Promise  is a JS object is an eventual completion or failure of asynchronous operation.
States:
pending ‚Üí operation ongoing


fulfilled ‚Üí operation successful


rejected ‚Üí operation failed

function fetchData() {
  return new Promise((reject, resolve) => {
    setTimeout(() => {
      let success = true;
      if (success) resolve("successful");
      else {
        reject("Error Ocurred");
      }
    }, 4000);
  });
}
fetchData()
  .then((result) => {
    console.log(result, "resultttttttttttttttt");
  })
  .catch((error) => {
    console.log(error);
  });
// output :- successful


Q.5) Difference between == and ===
let a = "5";
let b = 5;
console.log(a ==b);// true because this checks value not type ; loose equality
console.log(a===b);// false because this checks value plus type; strict eqality 

Q.6) Callback function
function Sum(a, b) {
  console.log(a + b);
}

function calculator(a, b, sumcallback) {
  sumcallback(a, b);
}
calculator(1, 2, (a, b) => {
  console.log(a + b);
});

Q.7) Spread and Rest operator
Spread:- 
const user = { name: "Alice", age: 25 };
const updatedUser = { ...user, age: 26 }; // Copy and update

console.log(updatedUser); // { name: "Alice", age: 26 }

Rest:- 
const [first, ...others] = [10, 20, 30, 40];
console.log(first);  // 10
console.log(others); // [20, 30, 40]

 | Feature | Spread (`...`)                  | Rest (`...`)                   |
| ------- | ------------------------------- | ------------------------------ |
| Purpose | Expands values                  | Gathers values                 |
| Used in | Arrays, Objects, Function calls | Function params, Destructuring |
| Output  | Individual elements             | Array of grouped elements      |

//Return promises using try  catch async await and .then .catch

//using .then or .catch
function fetchData(str) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (str === "patidev") resolve("patidev");
      else {
        reject("error");
      }
    }, 2000);
  });
}
fetchData("patidev")
  .then((data) => {
    console.log(data);
  })
  .catch((error) => {
    console.log(error);
  });

//using async await
const fetchOne = async (str) => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (str === "sandhya") resolve("success");
      else {
        reject("error Occure");
      }
    }, 2000);
  });
};

const fetchTwo = async (str) => {
  try {
    const result = await fetchOne(str);
    console.log(result, "resultt");
  } catch (error) {
    console.log("ERROR", error);
  }
};

fetchTwo("sanda");

//7th july interview question
const arr = [10, 20, 30, 40, 50];
const [first, , ...rest] = arr;
 
console.log(first); 
console.log(rest);
//output: 10
//[30,40,50]


Question.) 
solution:- 
console.log("Start");
 
async function asyncFunc() {
  console.log("Inside asyncFunc");
  await Promise.resolve();
  console.log("After await");
}
 
asyncFunc();
console.log("End");
Output
//start
//Inside asyncFunc
//End
//After await



//Maximum occurence key  from sandhya
// Online Javascript Editor for free
// Write, Edit and Run your Javascript code using JS Online Compiler

let str = "saannandhya";
let charCount = {};
let uniqueStr = [];
for(let char of str){
    charCount[char] = (charCount[char] || 0) +1;
}
console.log(charCount,'charCount-----------')
for( let key in charCount){
    if(charCount[key]>1){
        uniqueStr.push(key);
    }
}
console.log(uniqueStr,'uniqueStr-----------')

let maxOccure = 0
for(let key in charCount){
    if(charCount[key] > maxOccure){
        maxOccure = charCount[key];
  }
}
console.log(maxOccure, 'maxOc---------')

//output:-
{ s: 1, a: 4, n: 3, d: 1, h: 1, y: 1 } charCount-----------
[ 'a', 'n' ] uniqueStr-----------
4 maxOc---------

RATE LIMITING : -
Rate limiting controls how many request a user and server can make the server in the given period of time.


import expressLimit from "express-rate-limiter";

const rateLimit = rateLimit({
  windowMs : 15 * 60 * 1000; //15 min
  max: 1000;
})
app.use(rateLimit)
 output: -

 | Feature     | JWT (JSON Web Token)                                  | Session                                       |
| ----------- | ----------------------------------------------------- | --------------------------------------------- |
| Storage     | Stored on client (usually in localStorage or cookies) | Stored on server (with session ID in cookies) |
| Scalability | More scalable (stateless)                             | Less scalable (requires session store)        |
| Security    | Need to secure tokens manually                        | Session data stays on server                  |
| Use Case    | APIs, mobile apps                                     | Traditional web apps                          |

Q.3
const nested = [1, [2, [3, 4], 5], 6];

// ES6 flat
const flat = nested.flat(2); // [1, 2, 3, 4, 5, 6]

// Recursively with reduce
const flatten = (arr) =>
  arr.reduce((acc, val) =>
    Array.isArray(val) ? acc.concat(flatten(val)) : acc.concat(val), []);

console.log(flatten(nested)); // [1, 2, 3, 4, 5, 6]



6) Find Even and Odd Numbers from Array
const arr = [1, 2, 3, 4, 5, 6];
const even = arr.filter(num => num % 2 === 0);
const odd = arr.filter(num => num % 2 !== 0);

console.log("Even:", even); // [2, 4, 6]
console.log("Odd:", odd);   // [1, 3, 5]


Virtual dom in react
### üß† What is the **Virtual DOM** in React?

The **Virtual DOM (VDOM)** is a lightweight **in-memory representation of the real DOM** (Document Object Model). React uses it to optimize updates and rendering in the browser.

---

### ‚úÖ Why Use Virtual DOM?

Direct manipulation of the **real DOM** is slow and expensive, especially in large applications. The virtual DOM provides a more efficient way of updating the UI.

---

### ‚öôÔ∏è How It Works in React:

1. **Initial Render:**

   * React creates a virtual DOM tree from JSX using `React.createElement()`.

2. **State/Prop Change:**

   * When state or props change, a **new virtual DOM** is created.

3. **Diffing:**

   * React compares the **new VDOM** with the **previous VDOM** using a process called **reconciliation**.
   * It identifies the minimal number of changes needed.

4. **DOM Update:**

   * Only the **necessary changes** are applied to the real DOM.

---

### üìà Benefits of Virtual DOM:

* ‚úÖ Faster performance (minimal real DOM manipulation)
* ‚úÖ Smooth user interface updates
* ‚úÖ Clean abstraction from the real DOM

---

### üñº Visual Example:

```jsx
const App = () => {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count is: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};


### üîÅ Real DOM vs Virtual DOM

| Feature      | Real DOM                     | Virtual DOM                  |
| ------------ | ---------------------------- | ---------------------------- |
| Update Speed | Slow                         | Fast                         |
| Manipulation | Direct                       | Abstracted                   |
| Performance  | Less efficient for large UIs | Highly optimized via diffing |



Q. type of null and undefined

let result;
console.log(typeof(result), 'undefined-----------');
// output:- undefined

let re = null; 
console.log(typeof(re), 'null-----------');
//output: -object in js


//HTML Question 06-08-2025
<div class="top"><button class="btn">click Me</button></div>

//css 
.top{
  color: blue;
  justify-content:center;
  align-items: center;
  height:100vh;
 
  display:flex;

}



//JavaScript Array push()
The push() method adds a new element to an array (at the end):

Example
const fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.push("Kiwi");


The pop() method returns the value that was "popped out":

Example
const fruits = ["Banana", "Orange", "Apple", "Mango"];
let fruit = fruits.pop();

JavaScript Arrays
The shift() Method
The shift() method removes the first element of an array (and "shifts" the other elements to the left):

Banana,Orange,Apple,Mango

Orange,Apple,Mango


JavaScript Arrays
The unshift() Method
The unshift() method adds new elements to the beginning of an array:

Banana,Orange,Apple,Mango

Lemon,Banana,Orange,Apple,Mango


//SPLICE
The splice() method can be used to add new items to an array:

Example
const fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.splice(2, 0, "Lemon", "Kiwi");

The splice() Method
The splice() method adds new elements to an array, and returns an array with the deleted elements (if any):
let removed = fruits.splice(2, 2, "Lemon", "Kiwi"); 

Original Array:
Banana,Orange,Apple,Mango

New Array:
Banana,Orange,Lemon,Kiwi

Removed Items:
Apple,Mango

//SPLICE METHOD
const fruits = ["Banana", "Orange", "Apple", "Mango"];
console.log(fruits, "fruits--"); //[ 'Banana', 'Orange', 'Apple', 'Mango' ]
console.log(fruits.splice(0, 2)); //[ 'Orange', 'Apple' ]
console.log(fruits, "fruits--2"); // ['Banana', 'Mango']

//Remove 2 element from start 0 index and then print rest of the element
const fruits = ["Banana", "Orange", "Apple", "Mango"];
let fruit = fruits.splice(2, 0, "Lemon", "Kiwi");

console.log(fruits); //[ 'Banana', 'Orange', 'Lemon', 'Kiwi', 'Apple', 'Mango' ]

/**
 * These all are modify in original array.
 * Push()
 * pop()
 * shift()
 * unshift()
 * splice()
 * slice()
 */

//slice method 1 element ko include karta hai or last elemnet me exclude karta hai
 const fruits = ["Banana", "Orange", "Lemon", "Apple", "Mango"];
const res = fruits.slice(1);

console.log(res); //[ 'Orange', 'Lemon', 'Apple', 'Mango' ]
console.log(fruits); //[ 'Banana', 'Orange', 'Lemon', 'Apple', 'Mango' ]

//
const fruits = ["Banana", "Orange", "Lemon", "Apple", "Mango"];
console.log(fruits.slice(1, 4)); //[ 'Orange', 'Lemon', 'Apple' ]

//Key Points COOKIES

Size limit: Around 4 KB per cookie.

Data type: Only stores strings.

Scope: Can be restricted to a specific domain and path.

Lifetime:

Session cookies ‚Üí deleted when the browser closes.

Persistent cookies ‚Üí expire after a set date/time.

Access:

Can be accessed via JavaScript (document.cookie) unless marked HttpOnly.

Always sent to the server with requests to the same domain.


## Cookies definition:
A cookie is a small piece of data that a website stores on a 
user‚Äôs browser to remember information across visits or page loads.